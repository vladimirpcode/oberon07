
<!DOCTYPE html>
<html lang="en">
<head>
	<!-- Yandex.Metrika counter -->
	<script>
		var lang = 'en';
	   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
	   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
	   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

	   ym(65161051, "init", {
		    clickmap:false,
		    trackLinks:true,
		    accurateTrackBounce:true
	   });
	</script>
	<!-- /Yandex.Metrika counter -->

	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	<meta name="viewport" content="width=device-width"> <!-- device-width, initial-scale=1  -->
	<meta name="yandex-verification" content="4fd03922871ea99c" />
	
	<link href='https://fonts.googleapis.com/css?family=Exo+2:300,400&subset=latin,cyrillic' rel='stylesheet' type='text/css'>
	<title>Язык программирования Оберон 2013/2016</title>	
	<link rel="stylesheet" type="text/css" href="/style4.css"/>
	
	<link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
	<link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
	<link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
	<link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
	<link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
	<link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
	<link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
	<link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
	<link rel="icon" type="image/png" sizes="192x192"  href="/android-icon-192x192.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/manifest.json">
	<meta name="msapplication-TileColor" content="#ffffff">
	<meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
	<meta name="theme-color" content="#ffffff">
</head>

<body style='margin-bottom:100px;'>
<div style='margin-top: 0px; background: #222222; text-align: left; min-width: 640px;'>
	<div class='center' style='padding-top: 10px; text-align: left;'><a href=http://sfu-kras.ru/en><img src='/face/logo-en.svg' onerror="this.onerror=null; this.src='/face/main-logo.png'" alt="Сибирский федеральный университет" width='148' height='63' style='float: right; margin: 10px; margin-top: 5px; border: 0px;'></a> <a href='/' style=' text-decoration: none;'><div style='font-size: 17pt; color: #FFFFFF; padding: 8px; padding-top: 8px; padding-left: 20px; padding-bottom: 16px; max-width: 400px; font-family: "Exo 2", sans-serif; letter-spacing: 1px;'>Visual Interactive Simulations for Education and Science</div></a>

<div style='display: table; width: 100%;'>
	<div style='display: table-row'><a style='display: table-cell' class='menu' href='/'>Home</a><a style='display: table-cell' class='menu' href='/about'>About</a><a style='display: table-cell' class='menu' href='/signup'>Create</a><a style='display: table-cell' class='menu' href='/signin'>Sign in</a> <a style='display: table-cell' class='menu' href='/?language=ru'>Русский</a></div></div></div>
	</div>

	<div id="pubZone" style="padding: 20px; min-width: 600px; position: relative; min-height: 100%; margin-bottom: 80px; ">
	<div class='center' style='text-align: justify; '><a href="https://www.inf.ethz.ch/personal/wirth/Oberon/Oberon07.Report.pdf">Оригинал объявления о языке на английском</a>

<h1>Язык программирования Оберон</h1>
<p>Ревизия 1.10.2013 / 3.5.2016</p>
<p>Никлаус Вирт</p>
<p><i>Делай просто, насколько возможно, но не проще этого. (А. Эйнштейн)</i></p>

<h2 id="content" class="black">Содержание</h2>
<ol>
<li><a href="#sec1">История и введение</a></li>
<li><a href="#sec2">Синтаксис</a></li>
<li><a href="#sec3">Словарь</a></li>
<li><a href="#sec4">Объявления и правила области видимости</a></li>
<li><a href="#sec5">Объявления констант</a></li>
<li><a href="#sec6">Объявления типов</a>
	<ol>
	<li><a href="#sec61">Базовые типы</a></li>
	<li><a href="#sec62">Типы массив</a></li>
	<li><a href="#sec63">Типы запись</a></li>
	<li><a href="#sec64">Типы указатель</a></li>
	<li><a href="#sec65">Процедурный тип</a></li>
	</ol></li>
<li><a href="#sec7">Объявления переменных</a></li>
<li><a href="#sec8">Выражения</a>
	<ol>
	<li><a href="#sec81">Операнды</a></li>
	<li><a href="#sec82">Операции</a></li>
	</ol></li>
<li><a href="#sec9">Операторы</a>
	<ol>
	<li><a href="#sec91">Присваивания</a></li>
	<li><a href="#sec92">Вызовы процедур</a></li>
	<li><a href="#sec93">Последовательность операторов</a></li>
	<li><a href="#sec94">Операторы If</a></li>
	<li><a href="#sec95">Операторы Case</a></li>
	<li><a href="#sec96">Операторы While</a></li>
	<li><a href="#sec97">Операторы Repeat</a></li>
	<li><a href="#sec98">Операторы For</a></li>
	</ol></li>
<li><a href="#sec10">Объявления процедур</a>
	<ol>
	<li><a href="#sec101">Формальные параметры</a>
	<li><a href="#sec102">Предопределенные процедуры-функции</a></li>
	</ol></li>
<li><a href="#sec11">Модули</a>
	<ol>
	<li><a href="#sec111">Модуль SYSTEM</a></li>
	</ol></li>
	<a href="#appendix">Приложение: Синтаксис Оберона</a>
</ol>




<h2 id="sec1" class="black">1. История и введение</h2>

<p>Оберон — язык программирования общего назначения, являющийся развитием языка Модула-2. Его принципиальная новая особенность — концепция расширения типов. Эта особенность позволяет конструировать новые типы данных на основе существующих типов и устанавливать между ними отношения.</p>

<p>Этот документ не является учебником по программированию. Он преднамеренно краток. Его назначение — служить эталоном для программистов, разработчиков компиляторов и авторов руководств. Если о чем-то не сказано, то обычно сознательно: или потому, что это следует из других правил языка, или потому, что это может нежелательно ограничить свободу разработчикам компиляторов.</p>

<p>Настоящий документ описывает язык, определенный в 1988/90 в редакции 2007 / 2016 годов.</p>

<h2 id="sec2" class="black">2. Синтаксис</h2>

<p>Язык представляет собой бесконечное множество предложений, а именно предложений, правильно оформленных в соответствии с его синтаксисом. В Обероне, эти предложения называются единицами компиляции. Каждая единица представляет собой ограниченную последовательность из ограниченного словаря. Словарь Оберона состоит из идентификаторов, чисел, строк, операторов, разделителей и комментариев, которые называются <i>лексемами</i> и состоят из последовательностей <i>литер</i>.</p>

<p>Для описания синтаксиса используются <a href=https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B0_%D0%91%D1%8D%D0%BA%D1%83%D1%81%D0%B0_%E2%80%94_%D0%9D%D0%B0%D1%83%D1%80%D0%B0>расширенная Бэкус — Наурова форма (РБНФ)</a>. Квадратные скобки [ и ] означают необязательность записанного внутри них выражения, а фигурные скобки { и } означают его повторение (возможно 0 раз). Синтаксические сущности (нетерминальные лексемы) обозначаются английскими (в переводе — русскими) словами, выражающими их интуитивное значение. Лексемы словаря языка программирования (терминальные лексемы) обозначаются строками, заключенными в кавычки, или — заглавными буквами.</p>

<h2 id="sec3" class="black">3. Словарь</h2>

<p>Для составления лексем предусматривается использование следующих правил. Пробелы и переносы не должны встречаться внутри лексем (исключая комментарии и пробелы в строках). Они игнорируются, если они не существенны для отделения двух последовательных лексем. Заглавные и строчные буквы считаются различными.</p>

<p><i>Идентификаторы</i> — это последовательности букв и цифр. Первая литера идентификатора должна быть буквой.</p>

<pre>
 идент = буква {буква | цифра}.
</pre>

<p>Примеры:</p>

<pre>
 x  Scan  Oberon  GetSymbol  firstLetter
</pre>

<p><i>Числа</i> — это (беззнаковые) целые или вещественные числа. Целые числа являются последовательностью цифр и могут быть продолжены буквой суффикса. Если суффикса нет, то представление десятичное. Суффикс H указывает на шестнадцатеричное представление.</p>

<p><i>Вещественное число</i> всегда содержит десятичную точку. Опционально оно может также содержать десятичный порядок. Буква E означает «умножить на десять в степени».</p>
<pre>
 число       =  целое | вещественное.
 целое       =  цифра {цифра} | цифра {шестнЦифра} "H".
 вещественное  =  цифра {цифра} "." {цифра} [порядок].
 порядок       =  ("E") ["+" | "-"] цифра {цифра}.
 шестнЦифра  =  цифра | "A" | "B" | "C" | "D" | "E" | "F".
 цифра       =  "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9".
</pre>

<p>Примеры:</p>
<pre>
 1987
 100H     = 256
 12.3
 4.567E8  = 456700000
</pre>

<p><i>Строки</i> — это последовательность литер, заключенных в двойные кавычки ("). Ограничивающая кавычка не должна встречаться внутри строки. Альтернативно, строка из одной литеры может быть определена порядковым номером буквы в шестнадцатеричной нотации с последующей литерой "X". Число литер в строке называется <i>длиной</i> строки.</p>

<pre> строка = """ {литера} """ | цифра {шестнЦифра} "X".</pre>

<p>Примеры:</p>
<pre> "OBERON"    "Don't worry!"    22X </pre>

<p><i>Операции</i> и <i>разделители</i> — это специальные литеры, пары литер или зарезервированные слова, перечисленные ниже. Зарезервированные слова состоят исключительно из заглавных букв и не могут использоваться в качестве идентификаторов.
</p><pre>
 +	:=	ARRAY	IMPORT	THEN
 -	^	BEGIN	IN	TO
 *	=	BY	IS	TRUE
 /	#	CASE	MOD	TYPE
 ~	&lt;	CONST	MODULE	UNTIL
 &amp;	&gt;	DIV	NIL	VAR
 .	&lt;=	DO	OF	WHILE
 ,	&gt;=	ELSE	OR
 ;	..	ELSIF	POINTER
 |	:	END	PROCEDURE
 (	)	FALSE	RECORD
 [	]	FOR	REPEAT
 {	}	IF	RETURN
</pre>

<p><i>Комментарии</i> могут быть вставлены между любыми двумя лексемами в  программе. Они являются произвольными последовательностями литер, которые открываются скобкой <code>(*</code> и закрываются с помощью <code>*)</code>. Комментарии не влияют на смысл программы. Они могут быть вложенными.</p>


<h2 id="sec4">4. Объявления и правила области видимости</h2>

<p>Каждый идентификатор, встречающийся в программе, должен быть объявлен заранее, если это не предопределенный идентификатор. Объявления также служат для задания определенных постоянных свойств объекта, например, является ли он константой, типом, переменной или процедурой.</p>

<p>Позднее идентификатор используется для ссылки на соответствующий объект. Это возможно только в тех частях программы, которые находятся в пределах <i>области</i> объявления. Идентификатор не может обозначать больше чем один объект внутри данной области. Область распространяется текстуально от места объявления до конца блока (процедуры или модуля), к которому объявление принадлежит, и по отношению к которому объект является локальным.</p>

<p>Идентификатор, объявленный в блоке модуля, может сопровождаться меткой экспорта (*), чтобы указать, что он экспортируется из определяющего модуля. В этом случае, идентификатор может быть использован в других модулях, если они импортируют объявляющий модуль. В таком случае, идентификатор предваряется идентификатором, обозначающим его модуль (см. <a href="#sec11">Гл. 11</a>). Префикс и идентификатор разделены точкой и вместе называются <i>уточненным идентификатором</i>.</p>

<pre>
 уточнИдент  =  [идент "."] идент.
 идентОпр    =  идент ["*"].
</pre>

<p>Следующие идентификаторы являются предопределенными; их значение описано в разделе <a href="#sec61">6.1</a> (типы) или <a href="#sec102">10.2</a> (процедуры):</p>

<pre>
 ABS	ASR	ASSERT	BOOLEAN	BYTE
 CHAR	CHR	DEC	EXCL	FLOOR
 FLT	INC	INCL	INTEGER	LEN
 LSL	NEW	ODD	ORD	PACK
 REAL	ROR	SET	UNPK
</pre>


<h2 id="sec5" class="black">5. Объявления констант</h2>

<p>Объявление константы связывает ее идентификатор с ее значением.</p>

<pre>
 ОбъявлениеКонстанты  = идентОпр "=" КонстВыражение.
 КонстВыражение       = выражение.
</pre>

<p>Константное выражение может быть вычислено при транслировании текста программы без ее выполнения. Операнды константного выражения также являются константами (см. <a href="#sec8">Гл. 8</a>). Примеры объявления констант:</p>

<pre>
 N = 100
 limit = 2*N-1
 all = {0 .. WordSize-1}
 name = "Oberon"
</pre>


<h2 id="sec6" class="black">6. Объявления типов</h2>

<p>Тип данных определяет множество значений, которые могут принимать переменные этого типа, и применимые операций. Объявление типа используется для связи идентификатора с типом. Типы определяют структуру переменных этого типа и, как следствие, операции, которые применимы к компонентам. Существуют две разные структуры данных, а именно массивы и записи, с различными способами обращения к их компонентам (с различными селекторами).</p>

<pre>
 ОбъявлениеТипа = идентОпр "=" тип.
 тип = уточнИдент | ТипМассив | ТипЗапись | ТипУказатель | ПроцедурныйТип.
</pre>

<p>Примеры:</p>

<pre>
 Table      = ARRAY N OF REAL
 Tree       = POINTER TO Node
 Node       = RECORD key: INTEGER;
                 left, right: Tree
              END
 CenterNode = RECORD (Node)
                 name: ARRAY 32 OF CHAR;
                 subnode: Tree
              END
 Function   = PROCEDURE (x: INTEGER): INTEGER
</pre>

<h3 id="sec61" class="black">6.1 Элементарные типы</h3>

<p>Следующие элементарные типы обозначаются предопределенными идентификаторами. Соответствующие операции определены в <a href="#sec82">8.2</a>, а предопределенные процедуры-функции — в <a href="#sec102">10.2</a>. Значения элементарных типов таковы:</p>
<pre>
 BOOLEAN   логические значения TRUE и FALSE
 CHAR      литеры стандартного набора литер
 INTEGER   целые числа
 REAL      действительные числа
 BYTE      целые числа от 0 до 255
 SET       набор целых чисел между 0 и пределом, зависящим от реализации
</pre>

<p>Тип BYTE совместим с типом INTEGER, и наоборот.</p>

<h3 id="sec62" class="black">6.2 Типы массив</h3>

<p>Массив — это структура, состоящая из фиксированного числа элементов одинакового типа, называемого <i>типом элементов</i>. Количество элементов массива называется его <i>длиной</i>. Элементы массива обозначаются индексами, которые являются целыми числами от 0 до длины массива минус 1.</p>

<pre>
 ТипМассив = ARRAY длина {"," длина} OF тип. 
 длина = КонстВыражение.
</pre>

<p>Объявление вида
<pre>
 ARRAY N0, N1, ..., Nk OF T
</pre>
понимается как сокращение объявления
<pre>
 ARRAY N0 OF
      ARRAY N1 OF
        ...
            ARRAY Nk OF T
</pre>

<p>Примеры типа массив:</p>
<pre>
 ARRAY N OF INTEGER 
 ARRAY 10, 20 OF REAL 
</pre>


<h3 id="sec63" class="black">6.3 Типы запись</h3>

<p>Запись — это структура, состоящая из фиксированного числа элементов, которые могут иметь различные типы. Объявление типа запись задает для каждого элемента, называемого <i>полем</i>, его тип и идентификатор, который обозначает это поле. Область видимости идентификаторов полей — само определение записи, но они также доступны через обозначения поля (см. <a href="#sec81">8.1</a>), указывающее на элементы переменных типа запись.</p>

<pre>
 ТипЗапись = RECORD ["(" БазовыйТип ")"] [ПоследСпискаПолей] END.
 БазовыйТип = уточнИдент.
 ПоследСпискаПолей = СписокПолей {";" СписокПолей}.
 СписокПолей = СписокИдент ":" тип.
 СписокИдент = идентОпр {"," идентОпр}.
</pre>

<p>Если тип запись экспортируется, идентификаторы полей, которые должны быть видимыми вне модуля объявления, должны быть помечены. Они называются <i>общедоступными полями</i>; не отмеченные поля называются <i>приватными полями</i>.</p>

<p>Записи являются расширяемыми, т.е. запись может быть определена как расширение другой записи. В приведенных выше примерах <i>CenterNode</i> (напрямую) расширяет <i>Node</i>, который является его (прямым) базовым типом <i>CenterNode</i>. А именно, <i>CenterNode</i> расширяет <i>Node</i> полями <i>name</i> и <i>subnode</i>.</p>

<p><i>Определение</i>: тип <i>T</i> расширяет тип <i>T0</i>, если он и есть <i>T0</i>, или если он непосредственно расширяет расширение <i>T0</i>. И наоборот, тип <i>T0</i> является базовым типом для типа <i>T</i>, если он и есть <i>T</i>, или если он является прямым базовым типом базового типа <i>T</i>.</p>

<p>Примеры типов запись:</p>
<pre>
 RECORD day, month, year: INTEGER
 END 
 RECORD
   name, firstname: ARRAY 32 OF CHAR;
   age: INTEGER;
   salary: REAL
 END
</pre>

<h3 id="sec64" class="black">6.4 Типы указатель</h3>

<p>Переменные типа указатель <i>P</i> принимают в качестве значений указатели на переменные некоторого типа <i>T</i>. Этот тип должен быть записью. Тип указатель <i>P</i> называется <i>связанным с типом T</i>, а <i>T</i> — является <i>базовым типом указателя P</i>. Типы указатель наследуют отношение расширения базовых типов, если они есть. Если тип <i>T</i> является расширением <i>T0</i> и <i>P</i> является указателем, связанным с <i>T</i>, то тогда <i>P</i> также является расширением <i>P0</i>, который является указателем, связанным с <i>T0</i>.</p>

<pre>
 ТипУказатель = POINTER TO тип.
</pre>

<p>Если тип <i>P</i> определён как POINTER TO T, идентификатор T может быть текстуально объявлен после объявления P, но [если это так] он должен находиться в пределах одной области.</p>

<p>Если <i>p</i> — переменная типа P = POINTER TO T, то вызов предопределённой процедуры NEW(p) имеет следующий эффект (см. <a href="#sec102">10.2</a>): в свободной памяти выделяется место для переменной типа <i>T</i>, и указатель на нее присваивается к <i>p</i>. Этот указатель <i>p</i> типа <i>P</i> ссылается на переменную <i>p^</i> типа <i>T</i>. Ошибка выделения памяти под структуру приводит к тому, что <i>p</i> присваивается значение <i>NIL</i>. Каждой переменной типа указатель может быть присвоено значение <i>NIL</i>, которое не указывает ни на какую переменную вообще.</p>


<h3 id="sec65" class="black">6.5 Процедурные типы</h3>

<p>Переменные процедурного типа <i>T</i> принимают в качестве значения процедуру или NIL. Если процедура <i>P</i> связана с переменной процедурного типа <i>T</i>, то типы формальных параметров процедуры <i>P</i> должны совпадать с типами соответствующих формальных параметров типа <i>T</i>. То же самое справедливо для типа результата в случае процедур-функций (см. <a href="#sec101">10.1</a>). <i>P</i> не может быть локальной в другой процедуре, и также не может быть стандартной процедурой.</p>

<pre>
 ПроцедурныйТип = PROCEDURE [ФормальныеПараметры].
</pre>

<h2 id="sec7" class="black">7. Объявления переменных</h2>

<p>Объявления переменных служат для введения переменных и связывания их с идентификаторами, которые должны быть уникальными в пределах заданной области определения. Они также служат для связывания фиксированных типов данных с переменными.</p>

<pre>
 ОбъявлениеПеременных = СписокИдент ":" тип.
</pre>

<p>Переменные, идентификаторы которых отображаются в одном списке, имеют один общий тип. Примеры объявления переменных (отсылка к примерам в Гл. <a href="#sec6">6</a>):</p>

<pre>
 i, j, k: INTEGER
 x, y:    REAL
 p, q:    BOOLEAN
 s:       SET
 f:       Function
 a:       ARRAY 100 OF REAL 
 w:       ARRAY 16 OF 
             RECORD ch: CHAR; 
                count: INTEGER 
             END
 t:       Tree
</pre>


<h2 id="sec8" class="black">8. Выражения</h2>

<p>Выражения — это конструкции, которые задают правила вычисления значений с использованием констант и текущих значений переменных, применяя операции и процедуры-функции. Выражения состоят из операндов и операций. Круглые скобки могут использоваться для группировки операций и операндов.</p>


<h3 id="sec81" class="black">8.1 Операнды</h3>

<p>За исключением множеств и литерных констант, то есть чисел и строк, операнды определяются <i>обозначениями</i>. Обозначение может быть идентификатором константы, переменной или процедуры. Этот идентификатор может быть уточнен идентификатором модуля (см. Гл. <a href="#sec4">4</a> и <a href="#sec11">11</a>) и может сопровождаться селекторами, если обозначенный объект — часть структуры.</p>

<p>Если <i>A</i> обозначает массив, то <i>A[E]</i> обозначает тот элемент <i>A</i>, индекс которого является текущим значением выражения <i>E</i>. Результат <i>E</i> должен иметь тип INTEGER. Обозначение вида <i>A[E1, E2, ..., En]</i> значит <i>A[E1][E2]...[En]</i>. Если <i>p</i> обозначает переменную-указатель, <i>p^</i> обозначает переменную, на которую ссылается <i>p</i>. Если <i>r</i> обозначает запись, то <i>r.f</i> обозначает поле <i>f</i> из записи <i>r</i>. Если <i>p</i> обозначает указатель, <i>p.f</i> обозначает поле <i>f</i> записи <i>p^</i>, то есть точка подразумевает разыменование, и <i>p.f</i> означает <i>p^.f</i>.</p>

<p>Охрана типа <i>v(Т0)</i> обеспечивает, чтобы <i>v</i> имел тип <i>T0</i>, то есть охрана типа прекращает выполнение программы, если <i>v</i> имеет тип отличный от <i>T0</i>. Охрана применима, если:</p>
<ol>
<li><i>T0</i> является расширением объявленного типа <i>T</i> в <i>v</i>, и если </li>
<li><i>v</i> — переменный параметр типа запись, или <i>v</i> — указатель. </li>
</ol>
 
<pre>
 обозначение = уточнИдент {селектор}.
 селектор = "." идент | "[" СписокВыражений "]" | "^" | "(" уточнИдент ")".
 СписокВыражений = выражение {"," выражение}.
</pre>

<p>Если обозначенный объект является переменной, то обозначение ссылается на текущее значение переменной. Если объект является процедурой, обозначение без списка параметров ссылается на эту процедуру. Если за обозначением следует список параметров (возможно, пустой), обозначением подразумевает активацию процедуры и обозначает возвращаемый результат её исполнения. Фактические параметры (и их типы) должны соответствовать формальным параметрам, указанным в объявлении процедуры (см. Гл. <a href="#sec10">10</a>).</p>

<p>Примеры обозначений (см. примеры в Гл. <a href="#sec7">7</a>):</p>
<pre>
 i                      (INTEGER)
 a[i]                   (REAL)
 w[3].ch                (CHAR)
 t.key                  (INTEGER)
 t.left.right           (Tree)
 t(CenterNode).subnode  (Tree)
</pre>
 

<h3 id="sec82" class="black">8.2 Операции</h3>

<p>В синтаксисе выражений различаются четыре класса операций с различными приоритетами (порядком выполнения). Операция ~ имеет наивысший приоритет, за которой следуют мультипликативные операции, аддитивные операции и отношения. Операции одного приоритета выполняются слева направо. Например, x–y–z означает (x–y)–z.</p>

<pre>
 выражение = ПростоеВыражение [отношение ПростоеВыражение].
 отношение = "=" | "#" | "<" | "<=" | ">" | ">=" | IN | IS. 
 ПростоеВыражение  =  ["+"|"−"] слагаемое {ОперацияСложения слагаемое}. 
 ОперацияСложения  =  "+" | "−" | OR. 
 слагаемое = множитель {ОперацияУмножения множитель}. 
 ОперацияУмножения = "*" | "/" | DIV | MOD | "&" . 
 множитель = число | строка | NIL | TRUE | FALSE | множество |
   обозначение [ФактическиеПараметры] | "(" выражение ")" | "~" множитель. 
 множество = "{" [элемент {"," элемент}] "}". 
 элемент = выражение [".." выражение]. 
 ФактическиеПараметры = "(" [СписокВыражений] ")" . 
</pre>

<p>Множество {m..n} значит {m, m+1, ..., n-1, n}, а если m > n, то пустое множество. Доступные операторы перечислены в таблицах ниже. В некоторых случаях несколько разных операций обозначаются одной и той же лексемой. В этих случаях фактическая операция определяется типом операндов.</p>


<h4 id="sec821"><i>8.2.1 Логические операции</i></h4>

<pre>
 <u>Лексема  Результат</u>
 OR      логическая дизъюнкция
 &       логическое соединение
 ~       отрицание
</pre>

<p>Эти операции применяются к операндам BOOLEAN и дают результат BOOLEAN.</p>

<pre>
 р OR q  означает «если р, то TRUE, иначе q»
 p & q   означает «если р, то q, иначе FALSE»
 ~ p     означает «не p»
</pre>


<h4 id="sec822"><i>8.2.2 Арифметические операции</i></h4>

<pre>
 <u>Лексема  Результат</u>
 +       сумма
 -       разность
 *       произведение
 /       вещественное деление
 DIV     деление нацело
 MOD     остаток
</pre>

<p>Операции +, -, * и / применяются к операндам числовых типов. Оба операнда должны быть одного типа, что также определяет тип результата. При использовании в качестве унарных операций "-" обозначает инверсию знака, а "+" обозначает операцию идентичности.</p>

<p>Операции DIV и MOD применяются только к целочисленным операндам. Пусть q = x DIV y и r = x MOD y. Тогда множитель <i>q</i> и остаток <i>r</i> определяются уравнением</p>

<pre>
 X = q*y + r          0 <= r < y
</pre>


<h4 id="sec823"><i>8.2.3 Операции над множествами</i></h4>

<pre>
 <u>Лексема  Результат</u>
 +       объединение 
 -       разность 
 *       пересечение 
 /       cимметрическая разность множеств
</pre>

<p>Когда используется с одним операндом типа SET, знак минус обозначает дополнение множества.</p>


<h4 id="sec824"><i>8.2.4 Отношения</i></h4>

<pre>
 <u>Лексема  Отношение</u>
 =       равно 
 #       неравно 
 <       меньше 
 <=      меньше или равно 
 >       больше 
 >=      больше или равно 
 IN      членство в наборе 
 IS      проверка типа
</pre>

<p>Отношения являются логическими операциями. Отношение упорядочения <, <=, >, >= применяется к числовым типам, CHAR и литерным массивам. Отношения = и # применимы также к типам BOOLEAN, SET, указателям и процедурным типам.</p>

<p><i>x IN s</i> обозначает «x является элементом s». <i>x</i> должен иметь тип INTEGER и <i>s</i> должен быть типом SET.</p>

<p><i>v IS T</i> означает «v имеет тип T» и называется <i>проверкой типа</i>. Это применимо, если</p>
<ol>
<li>T — расширение объявленного типа T0 для v, и если</li>
<li>v — переменный параметр типа записи или v — указатель.</li>
</ol>
<p>Предполагая, например, что T является расширением T0 и, что v является указателем на тип T0, тогда проверка <i>v IS T</i> определяет, является ли фактически назначенная переменная (не только T0, но и также) типом T. Значение <i>NIL IS T</i> не определено.</p>

<p>Примеры выражений (см. примеры в Гл. <a href="#sec7">7</a>):</p>

<pre>
 1987                 (INTEGER)
 i DIV 3              (INTEGER)
 ~ p OR q             (BOOLEAN)
 (I + j) * (i-j)      (INTEGER)
 s - {8, 9, 13}       (SET)
 a[i+j] * a [i-j]     (REAL)
 (0 <= i) & (i <100)  (BOOLEAN)
 t.key = 0            (BOOLEAN)
 K IN {i .. j-1}      (BOOLEAN)
 T IS CenterNode      (BOOLEAN)
</pre>


<h2 id="sec9" class="black">9. Операторы</h2>

<p>Операторы обозначают действия. Есть элементарные и структурные операторы. Элементарные операторы не состоят из каких-либо частей, которые сами являлись бы операторами. Это такие операторы как присваивание и вызов процедуры. Структурные операторы состоят из частей, которые сами являются операторами. Они используются, чтобы выразить последовательное и условное, выборочное и повторное исполнение. Операторы также могут быть пустыми, и в этом случае они не означают никаких действий. Пустой оператор включен для того, чтобы ослабить правила пунктуации в последовательностях операторов.</p>

<pre>
 оператор  =
 	[присваивание | ВызовПроцедуры
 	| ОператорIf | ОператорCase | ОператорWhile
 	| ОператорRepeat | ОператорFor]. 
</pre>


<h3 id="sec91" class="black">9.1 Присваивания</h3>

<p>Присваивание служит для замены текущего значения переменной на новое значение, заданное выражением. Оператор присваивания записывается как «:=» и произносится как <i>становится</i>.</p>
<pre>
 присваивание  =  переменная ":=" выражение.
</pre>

<p>Если значение параметра структурировано (имеет тип массив или запись), никакого присваивания ему или его элементам не допускаются. Для импортированных переменных также не допускаются присваивания.</p>

<p>Тип выражения должен быть таким же, как у обозначений. Имеют место следующие исключения:</p>
<ol>
<li>Константу NIL можно присвоить переменным любого типа указателя или процедуры.</li>
<li>Строки могут быть присвоены любому массиву литер, если количество литер в строке меньше, чем количество литер в массиве. (Добавляется нулевая литера). Строки, состоящие из одной литеры, также могут быть присвоены переменным типа CHAR.</li>
<li>В случае записей тип источника должен быть расширением типа адресата.</li>
<li>Открытый массив может быть присвоен массиву равного базового типа.</li>
</ol>

<p>Примеры присвоений (см. примеры в Гл. <a href="#sec7">7</a>):</p>
<pre>
 i := 0 
 p := i = j 
 x := FLT(i + 1) 
 k := (i + j) DIV 2 
 f := log2 
 s := {2, 3, 5, 7, 11, 13} 
 a[i] := (x+y) * (x-y) 
 t.key := i 
 w[i+1].ch := "A" 
</pre>


<h3 id="sec92" class='black'>9.2 Вызовы процедур</h3>

<p>Вызов процедуры активирует процедуру. Он может содержать список фактических параметров, которые заменяют соответствующие формальные параметры, определенные в объявлении процедуры (см. Гл. <a href="#sec10">10</a>). Соответствие устанавливается в порядке следования параметров в списках фактических и формальных параметров. Имеются два вида параметров: параметры-переменные и параметры-значения.</p>

<p>В случае переменных параметров, фактический параметр должен быть обозначением, обозначающим переменную. Если он обозначает элемент структурной переменной, селектор вычисляется, когда фактическая формальная замена / параметр имеет место, то есть перед выполнением процедуры. Если параметр является параметром значения, соответствующий фактический параметр должен быть выражением. Это выражение вычисляется до активации процедуры, и результирующее значение присваивается формальному параметру, который теперь представляет собой локальную переменную (см. также <a href="#sec101">10.1</a>).</p>

<pre>
 ВызовПроцедуры  =  обозначение [ФактическиеПараметры]. 
</pre>

<p>Примеры вызова процедур:</p>
<pre>
 ReadInt(i)		(см. <a href="#sec10">Гл. 10</a>) 
 WriteInt(2*j + 1, 6) 
 INC(w[k].count) 
</pre>


<h3 id="sec93" class='black'>9.3 Последовательность операторов</h3>

<p>Последовательность операторов, разделенных точкой с запятой, означает поочередное выполнение действий, заданных составляющими операторами. </p>

<pre>
 ПослОператоров  =  оператор {";" оператор}. 
</pre>


<h3 id="sec94" class='black'>9.4 Операторы If</h3>

<pre>
 ОператорIf = IF выражение THEN
 	ПослОператоров 
 {ELSIF выражение THEN
 	ПослОператоров} 
 [ELSE
 	ПослОператоров] 
 END.
</pre>

<p>Операторы If определяют условное выполнение охраняемых операторов. Логическое выражение, предшествующие последовательности операторов, будем называть <i>условием</i>. Условия проверяются последовательно одно за другим, пока очередное не окажется равным TRUE, после чего выполняется связанная с этим условием последовательность операторов. Если ни одно условие не удовлетворено, выполняется последовательность операторов, записанная после слова ELSE, если оно имеется.</p>

<p>Пример:</p>

<pre>
 IF (ch >= "A") & (ch <= "Z") THEN ReadIdentifier
 ELSIF (ch >= "0") & (ch <= "9") THEN ReadNumber
 ELSIF ch = 22X THEN ReadString
 END
</pre>

<h3 id="sec95" class='black'>9.5 Операторы Case</h3>

<p>Операторы Case определяют выбор и выполнение последовательности операторов по значению выражения. Сначала вычисляется выбирающее выражение, а затем выполняется та последовательность операторов, чей список меток варианта содержит полученное значение. Если выбирающее выражение имеет тип INTEGER или CHAR, то все метки должны быть целыми или строками из одной литеры, соответственно.</p>

<pre>
 ОператорCase = CASE выражение OF вариант {" | " вариант} END.
 вариант = [СписокМетокВарианта ":" ПослОператоров].
 СписокМетокВарианта = МеткиВарианта {"," МеткиВарианта }.
 МеткиВарианта = метка [".." метка].
 метка = целое | строка | уточнИдент.
</pre>

<p>Пример:</p>

<pre>
 CASE k OF
     0: x := x + y
   | 1: x := x − y
   | 2: x := x * y
   | 3: x := x / y
 END
</pre>

<p>Тип <i>T</i> оценочного выражения (оценочной переменной) также может быть записью или указателем. Тогда метки должны быть расширениями <i>T</i>, и в операторах <i>Si</i> помечены как <i>Ti</i>, и оценочные переменные рассматриваются как тип <i>Ti</i>.</p>

<p>Пример:</p>

<pre>
 TYPE R = RECORD a: INTEGER END ;
   R0 = RECORD (R) b: INTEGER END ;
   R1 = RECORD (R) b: REAL END ;
   R2 = RECORD (R) b: SET END ;
   P = POINTER TO R;
   P0 = POINTER TO R0;
   P1 = POINTER TO R1;
   P2 = POINTER TO R2;
 VAR p: P;
 
 CASE p OF
   P0: p.b := 10 |
   P1: p.b := 2.5 |
   P2: p.b := {0, 2}
 END
</pre>


<h3 id="sec96" class='black'>9.6 Операторы While</h3>

<p>Операторы While задают повторное выполнение. Если любое из  логических выражений (условий) возвращает TRUE, соответствующая последовательность операторов выполняется. Условия вычисляются и выполнение продолжается, пока хотя бы одно из логических выражений возвращает TRUE.</p>

<pre>
 ОператорWhile = WHILE выражение DO ПослОператоров 
    {ELSIF выражение DO ПослОператоров} END. 
</pre>

<p>Примеры:</p>

<pre>
 WHILE j > 0 DO
    j := j DIV 2; i := i+1
 END
 WHILE (t # NIL) & (t.key # i) DO
   t := t.left
 END
 WHILE m > n DO m := m - n
 ELSIF n > m DO n := n - m
 END
</pre>


<h3 id="sec97" class='black'>9.7 Операторы Repeat</h3>

<p>Операторы Repeat определяют повторное выполнение последовательности операторов пока условие, заданное логическим выражением, не удовлетворено. Последовательность операторов выполняется по крайней мере один раз.<p> 

<pre>
  ОператорRepeat = REPEAT ПослОператоров UNTIL выражение.  
</pre>

<h3 id="sec98" class='black'>9.8 Операторы For</h3>

<p>Операторы For определяют повторное выполнение последовательности операторов фиксированное число раз для прогрессии значений целочисленной переменной, называемой <i>управляющей переменной</i> оператора for.</p>

<pre>
 ОператорFor =
   FOR идент ":=" выражение TO выражение [BY КонстВыражение] DO 
   ПослОператоров END.
</pre>

Оператор
<pre>
 FOR v := beg TO end BY inc DO S END
</pre>
если inc > 0, эквивалентен
<pre>
 v := beg;
 WHILE v <= end DO S; v := v + inc END
</pre>
и если inc < 0, то эквивалентен
<pre>
 v := beg;
 WHILE v >= end DO S; v := v + inc END
</pre>

<p>Типы <i>v</i>, <i>beg</i> и <i>end</i> должны быть INTEGER, и <i>inc</i> должно быть целым (константным выражением). Если шаг не определен, то он предполагается равным 1.</p>

<h2 id="sec10" class="black">10. Объявления процедур</h2>

<p>Объявление процедуры состоит из заголовка процедуры и тела процедуры. Заголовок определяет имя процедуры, формальные параметры и тип результата (если он есть). Тело содержит объявления и операторы. Имя процедуры повторяется в конце объявления процедуры.</p>

<p>Имеются два вида процедур: собственно процедуры и процедуры-функции. Последние активизируются обозначением функции как части выражения и возвращают результат, который является операндом выражения. Собственно процедуры активизируются вызовом процедуры. Процедура-функция отличается в объявлении тем, что обозначает тип результата после списка параметров. Тело процедуры-функции должно содержать оператор возврата RETURN, который определяет ее результат.</p>

<p>Все константы, переменные, типы и процедуры, объявленные внутри тела процедуры, локальны в процедуре. Значения локальных переменных неопределены до входа в процедуру. Поскольку процедуры тоже могут быть объявлены как локальные объекты, объявления процедур могут быть вложенными.</p>

<p>Вдобавок к их формальным параметрам и локально объявленным объектам, объекты объявленные глобально также видны в процедуре.</p>

<p>Вызов процедуры изнутри ее объявления подразумевает рекурсивную активацию.</p>
<pre>
 ОбъявлениеПроцедуры = ЗаголовокПроцедуры ";" ТелоПроцедуры идент.
 ЗаголовокПроцедуры  = PROCEDURE идентОпр [ФормальныеПараметры].
 ТелоПроцедуры       = ПослОбъявлений [BEGIN ПослОператоров]
                       [RETURN выражение] END.
 ПослОбъявлений      = [CONST {ОбъявлениеКонстант ";"}]
                       [TYPE {ОбъявлениеТипов ";"}]
                       [VAR {ОбъявлениеПеременных ";"}] 
                       {ОбъявлениеПроцедуры ";"}.
</pre>


<h3 id="sec101" class='black'>10.1 Формальные параметры</h3>

<p>Формальные параметры — это идентификаторы фактических параметров, которые будут конкретизированы при вызове процедуры. Соответствие между формальными и фактическими параметрами устанавливается, когда процедура вызывается. Имеются два вида параметров: параметры-значения и параметры-переменные. Параметры-переменные соответствуют фактическим параметрам, которые являются переменными, и означают эти переменные. Параметр-значение соответствует фактическому параметру, который является выражением, и отвечает его значению, которое не может быть изменено присвоением. Однако, если параметр-значение имеет элементарный тип, то он представляет локальную переменную, к которой изначально присвоено значение фактического выраженя.</p>

<p>Тип параметра обозначен в списке формальных параметров: параметр-переменная обозначается лексемой VAR, а параметр-значение отсутствием такого префикса.</p>

<p>Процедура-функция без параметров должна иметь пустой список параметров. Она должна вызываться обозначением функции, чей список фактических параметров также пуст.</p>

<p>Формальные параметры локальны для процедуры, т.е. их область действия простирается в области текста программы, представляющего объявление процедуры.</p>

<pre>
 ФормальныеПараметры = "(" [СекцияФП {";" СекцияФП }] ")" [":" уточнИдент].
 СекцияФП            = [VAR] идент {"," идент} ":" ФормалныйТип.
 ФормалныйТип        = {ARRAY OF} уточнИдент.
</pre>

<p>Тип каждого формального параметра определен в списке параметров. Для параметров-переменных он должен быть идентичным соответствующему типу фактического параметра, кроме записей, когда он должен базовым типом соответствующего фактического параметра.</p>

<p>Если тип формального параметра определен как</p>

<pre>
 ARRAY OF T
</pre>

<p>то такой параметр называется открытым массивом, и соответствующий фактический параметр может быть произвольной длины.</p>

<p>Если формальный параметр определен как процедурный тип, то соответствующий фактический параметр должен быть либо процедурой, которая объявлена глобально, либо переменной (или параметром) процедурного типа. Также в этом случае фактический параметр не может быть предопределенной процедурой. Тип результата процедуры не может быть ни записью, ни массивом.</p> 

<p>Пример объявления процедур:</p>

<pre>
PROCEDURE ReadInt(VAR x: INTEGER);
    VAR i : INTEGER; ch: CHAR;
BEGIN i := 0; Read(ch);
    WHILE ("0" <= ch) & (ch <= "9") DO
            i := 10*i + (ORD(ch)-ORD("0")); Read(ch)
    END ;
    x := i
END ReadInt

PROCEDURE WriteInt(x: INTEGER); (* 0 <= x < 10^5 *)
    VAR i: INTEGER;
            buf: ARRAY 5 OF INTEGER;
BEGIN i := 0;
    REPEAT
       buf[i] := x MOD 10; x := x DIV 10; INC(i)
    UNTIL x = 0;
    REPEAT DEC(i); Write(CHR(buf[i] + ORD("0"))) UNTIL i = 0
END WriteInt

PROCEDURE log2(x: INTEGER): INTEGER;
    VAR y: INTEGER; (*assume x>0*)
BEGIN y := 0;
    WHILE x > 1 DO x := x DIV 2; INC(y) END ;
    RETURN y
END log2
</pre>


<h3 id="sec102" class="black">10.2 Предопределенные процедуры-функции</h3>

<p>Следующая таблица содержит список предопределенных процедур. Некоторые процедуры — обобщенные, то есть они применимы к операндам нескольких типов. Буква v обозначает переменную, x и n — выражения, T — тип.</p>

<p><i>Процедуры-функции:</i></p>

<pre>
<u>Имя         Типы аргумента    Тип результата   Функция</u>
ABS(x)      x: числовой тип   тип x            абсолютное значение
ODD(x)      x: INTEGER        BOOLEAN          x MOD 2 = 1
LEN(v)      v: массив         INTEGER          длина v
LSL(x, n)   x, n: INTEGER     INTEGER          логический сдвиг влево, x * 2<sup>n</sup>
ASR(x, n)   x, n: INTEGER     INTEGER          signed сдвиг вправо, x DIV 2<sup>n</sup>
ROR(x, n)   x, n: INTEGER     INTEGER          x вращается вправо на n бит
</pre>

<p><i>Функции преобразования типов:</i></p>

<pre>
<u>Имя       Типы аргумента       Тип результата   Функция</u>
FLOOR(x)  REAL                 INTEGER          округлить до меньшего
FLT(x)    INTEGER              REAL             тождественно
ORD(x)    CHAR, BOOLEAN, SET   INTEGER          порядковый номер x
CHR(x)    INTEGER              CHAR             литера с порядковым номером x
</pre>

<p><i>Собственно процедуры:</i></p>

<pre>
<u>Имя           Типы аргумента       Функция</u>
INC(v)        INTEGER              v := v + 1
INC(v, n)     INTEGER              v := v + n

DEC(v)        INTEGER              v := v - 1
DEC(v, n)     INTEGER              v := v - n

INCL(v, x)    v: SET; x: INTEGER   v := v + {x}
EXCL(v, x)    v: SET; x: INTEGER   v := v - {x}

NEW(v)        тип указатель        разместить v^

ASSERT(b)     BOOLEAN              прерывает программу, если ~b

PACK(x, n)    REAL; INTEGER        упаковывает x и n в x
UNPK(x, n)    REAL; INTEGER        распаковывает из x в x и n
</pre>

<p>Функция FLOOR(x) возвращает наибольшее целое не большее чем x.</p>

<pre>
FLOOR(1.5) = 1     FLOOR(-1.5) = -2
</pre>

<p>Параметр <i>n</i> процедуры PACK представляет экспоненту <i>x</i>. PACK(x, y) равнозначно x := x * 2<sup>y</sup>.</p>

<p>UNPK является обратной операцией. Результирующее <i>x</i> нормализовано, так что 1.0 <= x < 2.0. </p>




<h2 id="sec11" class="black">11. Модули</h2>

<p>Модуль — совокупность объявлений констант, типов, переменных и процедур вместе с последовательностью операторов, предназначенных для присваивания начальных значений переменным. Модуль обычно представляет собой текст, который возможно компилировать как целое (единица компиляции).</p>

<pre>
    Модуль        = МODULE идент ";" [СписокИмпорта] ПослОбъявлений
                    [BEGIN ПослОператоров] END идент ".".
    СписокИмпорта = IMPORT Импорт {"," Импорт} ";".
    Импорт        = [идент ":="] идент.
</pre>

<p>В списке импорта указаны модули, клиентом которых является модуль. Если идентификатор x экспортируется из модуля M, и если M указан в списке импорта модуля, тогда обращение к x осуществляется как M.x. Если в списке импорта используется форма <nobr>«M := M1»</nobr>, экспортируемый объект x, объявленный в M1, вызывается в импортирующем модуле как M.x.</p>

<p>Идентификаторы, которые должны быть видны в клиентских модулях, то есть должны быть экспортированы, должны быть отмечены звездочкой (отметкой экспорта) в их объявлении. Переменные всегда экспортируются в режиме <i>только для чтения</i>.</p>

<p>Последовательность операторов, следующая за лексемой BEGIN, выполняется, когда модуль добавляется в систему (загружается). Отдельные процедуры (без параметров) могут быть активированы из системы, и эти процедуры служат в качестве команд.</p>

<p>Пример:</p>

<pre>
MODULE Out;    (*exported procedures: Write, WriteInt, WriteLn*)
        IMPORT Texts, Oberon;
        VAR W: Texts.Writer;

        PROCEDURE Write*(ch: CHAR);
        BEGIN Texts.Write(W, ch)
        END <font color=red>Write</font>;

        PROCEDURE WriteInt*(x, n: INTEGER);
                VAR i: INTEGER; a: ARRAY 16 OF CHAR;
        BEGIN i := 0;
                IF x < 0 THEN Texts.Write(W, "-"); x := -x END ;
                REPEAT
                  a[i] := CHR(x MOD 10 + ORD("0")); x := x DIV 10; INC(i)
                UNTIL x = 0;
                REPEAT Texts.Write(W, " "); DEC(n) UNTIL n <= i;
                REPEAT DEC(i); Texts.Write(W, a[i]) UNTIL i = 0
        END WriteInt;

        PROCEDURE WriteLn*;
        BEGIN Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
        END WriteLn;

BEGIN Texts.OpenWriter(W)
END Out.
</pre>


<h3 id="sec111" class="black">11.1 Модуль SYSTEM</h3>

<p>Опциональный модуль SYSTEM содержит определения, которые необходимы для программирования низко-уровневых операций, прямо указывающих на ресурсы конкретного компьютера и/или реализации.</p> 

<p>Они содержат, к примеру, средства для доступа к устройствам, которые управляются компьютером, и, возможно, — средства для нарушения правил совместимости типов данных, иначе запрещенных по определению языка программирования.</p>

<p>Есть две причины для предоставления таких средств в Модуле SYSTEM; (1) Их значения зависят от реализации, то есть не выводятся из определения языка, и (2) они могут повредить систему (например PUT). Настоятельно рекомендуется ограничить использование этих средств специфическими модулями (модулями низкого уровня), так как такие модули по своей природе являются непереносимыми и небезопасны с точки зрения преобразования типов. Однако они легко распознаются по идентификатору SYSTEM в списке импорта. Следующие определения обычно применимы. Однако отдельные реализации могут включать в свои модули дополнительные определения SYSTEM, которые относятся к конкретному, находящемуся в основе компьютеру. В дальнейшем <i>v</i> обозначает переменную, <i>x</i>, <i>a</i> и <i>n</i> для выражений.</p>

<p><i>Процедуры-функции:</i></p>
<pre>
<u>Имя         Типы аргумента    Тип результата   Функция</u>
ADR(v)      любой             INTEGER          адрес переменной v
SIZE(T)     любой тип         INTEGER          размер в байтах
BIT(a, n)   a, n: INTEGER     BOOLEAN          бит n из mem[a]
</pre>

<p><i>Собственно процедуры:</i></p>
<pre>
<u>Имя                Типы аргумента                            Функция</u>
GET(a, v)          a: INTEGER; v: любой элементарный тип     v := mem[a]
PUT(a, x)          a: INTEGER; x: любой элементарный тип     mem[a] := x
COPY(src, dst, n)  все INTEGER   копирует <i>n</i> последовательных слова из <i>src</i> в <i>dst</i>
</pre>

<p>Ниже приводятся дополнительные процедуры, поддерживаемые компилятором для RISC-процессора:</p>

<p><i>Процедуры-функции:</i></p>

<pre>
<u>Имя         Типы аргумента  Тип результата  Функция</u>
VAL(T, n)   скаляр          T               тождество
ADC(m, n)   INTEGER         INTEGER         сложение с учётом флага переноса C
SBC(m, n)   INTEGER         INTEGER         вычитания с учётом флага переноса C
UML(m, n)   INTEGER         INTEGER         беззнаковое умножение
COND(n)     INTEGER         BOOLEAN         IF Cond(n) THEN ...
</pre>

<p><i>Собственно процедуры:</i></p>
<pre>
<u>Имя       Типы аргумента     Функция</u>
LED(n)    INTEGER            показать n на светодиодах
</pre>


<h2 id="appendix" class="black">Приложение: Синтаксис Оберона</h2>

<pre>
буква        =  "A" | "B" | ... | "Z" | "a" | "b" | ... | "z".
цифра        =  "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9".
шестнЦифра   =  цифра | "A" | "B" | "C" | "D" | "E" | "F".

идент        =  буква {буква | цифра}.
уточнИдент   =  [идент "."] идент.
идентОпр     =  идент ["*"].

целое        =  цифра {цифра} | цифра {шестнЦифра} "H".
вещественное =  цифра {цифра} "." {цифра} [порядок].
порядок	     =  ("E") ["+" | "-"] цифра {цифра}.
число        =  целое | вещественное.
строка       = """ {литера} """ | цифра {шестнЦифра} "X".

ОбъявлениеКонстанты  =  идентОпр "=" КонстВыражение.
КонстВыражение       =  выражение.

ОбъявлениеТипа  =  идентОпр "=" тип.
тип             =  уточнИдент | ТипМассив | ТипЗапись | ТипУказатель | ПроцедурныйТип.
ТипМассив       =  ARRAY длина {"," длина} OF тип. 
длина           =  КонстВыражение.
ТипЗапись       =  RECORD ["(" БазовыйТип ")"] [ПоследСпискаПолей] END.
БазовыйТип      =  уточнИдент.
ПоследСпискаПолей =  СписокПолей {";" СписокПолей}.
СписокПолей     =  СписокИдент ":" тип.
СписокИдент     =  идентОпр {"," идентОпр}.
ТипУказатель    =  POINTER TO тип.
ПроцедурныйТип  =  PROCEDURE [ФормальныеПараметры].

ОбъявлениеПеременных = СписокИдент ":" тип.

выражение           = ПростоеВыражение [отношение ПростоеВыражение].
отношение           = "=" | "#" | "<" | "<=" | ">" | ">=" | IN | IS. 
ПростоеВыражение    =  ["+"|"-"] слагаемое {ОперацияСложения слагаемое}. 
ОперацияСложения    =  "+" | "-" | OR. 
слагаемое           = множитель {ОперацияУмножения множитель}. 
ОперацияУмножения   = "*" | "/" | DIV | MOD | "&" . 
множитель           = число | строка | NIL | TRUE | FALSE | множество |
                      обозначение [ФактическиеПараметры] |
                      "(" выражение ")" | "~" множитель. 
обозначение         = уточнИдент {селектор}.
селектор            = "." идент | "[" СписокВыражений "]" | "^" | "(" уточнИдент ")".
множество           = "{" [элемент {"," элемент}] "}". 
элемент             = выражение [".." выражение]. 
СписокВыражений     = выражение {"," выражение}.
ФактическиеПараметры  = "(" [СписокВыражений] ")" . 

оператор            = [присвоение | ВызовПроцедуры | ОператорIf | ОператорCase |
                      ОператорWhile | ОператорRepeat | ОператорFor]. 
присвоение          = обозначение ":=" выражение
ВызовПроцедуры      = обозначение [ФактическиеПараметры].
ПослОператоров      = оператор {";" оператор}.
ОператорIf          = IF выражение THEN
                         ПослОператоров 
                      {ELSIF выражение THEN
                         ПослОператоров} 
                      [ELSE
                         ПослОператоров] 
                      END.
ОператорCase        = CASE выражение OF вариант {" | " вариант} END.
вариант             = [СписокМетокВарианта ":" ПослОператоров].
СписокМетокВарианта = МеткиВарианта {"," МеткиВарианта }.
МеткиВарианта       = метка [".." метка].
метка               = целое | строка | уточнИдент.
ОператорWhile       = WHILE выражение DO ПослОператоров 
                      {ELSIF выражение DO ПослОператоров} END. 
ОператорRepeat      = REPEAT ПослОператоров UNTIL выражение.
ОператорFor         = FOR идент ":=" выражение TO выражение [BY КонстВыражение] DO 
                      ПослОператоров END.

ОбъявлениеПроцедуры = ЗаголовокПроцедуры ";" ТелоПроцедуры идент.
ЗаголовокПроцедуры  = PROCEDURE идентОпр [ФормальныеПараметры].
ТелоПроцедуры       = ПослОбъявлений [BEGIN ПослОператоров]
                      [RETURN выражение] END.
ПослОбъявлений      = [CONST {ОбъявлениеКонстант ";"}]
                      [TYPE {ОбъявлениеТипов ";"}]
                      [VAR {ОбъявлениеПеременных ";"}] 
                      {ОбъявлениеПроцедуры ";"}.

ФормальныеПараметры = "(" [СекцияФП {";" СекцияФП }] ")" [":" уточнИдент].
СекцияФП            = [VAR] идент {"," идент} ":" ФормалныйТип.
ФормалныйТип        = {ARRAY OF} уточнИдент.

модуль              = MODULE идент ";" [СписокИмпорта] ПослОбъявлений
                      [BEGIN ПослОператоров] END идент ".".
СписокИмпорта       = IMPORT импорт {"," импорт} ";".
импорт              = [идент ":="] идент.
</pre>


<div style="float: right; padding-bottom: 300px; margin-top: 40px;">Перевод выполнил Иван Денисов<br><br>

Использованы:<br>
- <a href="https://pm.vogu35.ru/oberon/o2rus.htm">перевод Сергея Свердлова</a><br>
- <a href=https://bitbucket.org/oberoncore/bb-docu-ru>перевод пакета Дельта</a><br>
- <a href=https://informatika-21.ru/software.htm>перевод из сборки проектра Информатика-21</a><br>
- <a href=https://forum.oberoncore.ru/viewtopic.php?f=115&t=3026>перевод Бурцева Вадима</a><br>
- <a href="https://docs.google.com/document/d/1qcldcIVZ0SfBPa7IS3D_Ty35mki1YeCcB2N2CXrv9Fo">перевод Валерия Шипкова</a>.<br>
Благодарность за замечания по переводу:<br>
- Александру Ширяеву,<br>
- Артуру Ефимову,<br>
- Александру Легалову,<br>
- Константину (comdivbyzero).
</div>

</div>	</div>
	
		
	
	<div id='debug'></div>
	<noscript><div><img src="https://mc.yandex.ru/watch/65161051" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
</body>
</html>


				

